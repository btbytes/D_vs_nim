# SCRATCH

TODO: organize these in other sections in the readme

## nim notes

* nim makes some common idioms in D first-class citizens. For example, imperative type declarations are first-class citizens so all the boiler plate around "if (isInputRange!(R))" type stuff goes away in Nim

* Nim is the only language that leverages automated proof technology to perform a disjoint check for your parallel code. Working on disjoint data means no locking is required and yet data races are impossible:

```
parallel:
  var i = 0
  while i <= a.high:
    spawn f(a[i])
    spawn f(a[i+1])
    # ERROR: cannot prove a[i] is disjoint from a[i+1]
    # BUT: replace 'i += 1' with 'i += 2' and the code compiles!
    i += 1
```

* The syntax seems more orthogonal with fewer bultin constructs and many generated by library, eg: 'a>b is a hygyenic macro that generates 'b<a'; associative arrays (tables) are in library

## gotchas
*  

## nim questions
* test whether import order matters
* how to list all functions(reflection)
* `var a,b:int` ok but not `fun((a,b:int)=>a+b)` ?
* how to do nested types? cf D20180330T115220
* how to do `hasField!(T, "foo")` ? cf https://forum.nim-lang.org/t/3655 Compile-time type reflection API?
* could concepts match error show which definition failed?
* how to do a union? (in the sense of C, C++, D)


## nim questions (with answers)

how would I translate this from D to Nim?

`void fun(T)(T a) if (isFoo!T){...}`

`isFoo` could be any kind of contraint on T, eg see https://dlang.org/phobos/std_traits.html for some standard ones (eg: `isSigned` to only match signed integral types)
This pattern is used all over D code, allowing for eg duck typing or providing specialized implementations depending on arbitrary properties of T.

A: IIRC, `proc fun[T](T a):auto = ...`  uses generic polymorphism and doesn't allow overloading
but this seems to work:
```nim
type isFoo = concept a
  # etc
proc fun(a: isFoo)
```

